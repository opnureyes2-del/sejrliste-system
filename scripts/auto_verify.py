#!/usr/bin/env python3
"""
Auto-verify sejr liste completion with 3-PASS SYSTEM
Part of SEJR LISTE SYSTEM - DNA Layer 3 (SELF-VERIFYING)

INGEN EXTERNAL DEPENDENCIES - Kun Python standard library

3-PASS KONKURRENCE:
- Pass 1: Get it working (basic functionality)
- Pass 2: Make it better (improvements required)
- Pass 3: Make it best (optimization + final verification)

REGEL: Kan IKKE arkiveres f√∏r alle 3 passes er gennemf√∏rt og verificeret.
"""

import argparse
import subprocess
import re
from pathlib import Path
from datetime import datetime


# ============================================================================
# SIMPLE YAML PARSING (No PyYAML dependency)
# ============================================================================

def parse_yaml_simple(filepath: Path) -> dict:
    """Parse simple YAML without PyYAML."""
    if not filepath.exists():
        return {}

    result = {}
    try:
        content = filepath.read_text(encoding="utf-8")
        for line in content.split("\n"):
            if ":" in line and not line.strip().startswith("#"):
                parts = line.split(":", 1)
                if len(parts) == 2:
                    key = parts[0].strip()
                    value = parts[1].strip().strip('"').strip("'")
                    if value.lower() == "true":
                        value = True
                    elif value.lower() == "false":
                        value = False
                    elif value == "null":
                        value = None
                    elif value.replace(".", "").replace("-", "").isdigit():
                        value = float(value) if "." in value else int(value)
                    result[key] = value
    except:
        pass
    return result


def write_yaml_simple(filepath: Path, data: dict):
    """Write simple YAML without PyYAML."""
    lines = ["# STATUS.yaml - Auto-generated by auto_verify.py"]
    lines.append(f"# Last updated: {datetime.now().isoformat()}")
    lines.append("")

    for key, value in data.items():
        if isinstance(value, bool):
            value_str = "true" if value else "false"
        elif isinstance(value, (int, float)):
            value_str = str(value)
        elif value is None:
            value_str = "null"
        else:
            value_str = f'"{value}"'
        lines.append(f"{key}: {value_str}")

    filepath.write_text("\n".join(lines) + "\n", encoding="utf-8")


# ============================================================================
# 3-PASS VERIFICATION SYSTEM
# ============================================================================

def detect_current_pass(content: str) -> int:
    """Detect which pass is currently active based on checkbox completion."""
    # Check Pass 1 completion (matches actual SEJR_LISTE.md format with emojis)
    pass1_section = extract_section(content, "# ü•â PASS 1:", "# üîç PASS 1 ‚Üí")
    pass1_done, pass1_total = count_checkboxes(pass1_section)

    # Check Pass 1 Review
    pass1_review = extract_section(content, "# üîç PASS 1 ‚Üí", "# ü•à PASS 2:")
    pass1_review_done, pass1_review_total = count_checkboxes(pass1_review)

    # Check Pass 2 completion
    pass2_section = extract_section(content, "# ü•à PASS 2:", "# üîç PASS 2 ‚Üí")
    pass2_done, pass2_total = count_checkboxes(pass2_section)

    # Check Pass 2 Review
    pass2_review = extract_section(content, "# üîç PASS 2 ‚Üí", "# ü•á PASS 3:")
    pass2_review_done, pass2_review_total = count_checkboxes(pass2_review)

    # Check Pass 3 completion
    pass3_section = extract_section(content, "# ü•á PASS 3:", "# üì¶ SEMANTISK KONKLUSION")
    pass3_done, pass3_total = count_checkboxes(pass3_section)

    # Determine current pass
    if pass1_total > 0 and pass1_done < pass1_total:
        return 1
    elif pass1_review_total > 0 and pass1_review_done < pass1_review_total:
        return 1  # Still in review phase of pass 1
    elif pass2_total > 0 and pass2_done < pass2_total:
        return 2
    elif pass2_review_total > 0 and pass2_review_done < pass2_review_total:
        return 2  # Still in review phase of pass 2
    elif pass3_total > 0 and pass3_done < pass3_total:
        return 3
    elif pass3_done == pass3_total and pass3_total > 0:
        return 3  # Pass 3 complete

    return 1  # Default to pass 1


def extract_section(content: str, start_marker: str, end_marker: str) -> str:
    """Extract a section of content between markers."""
    start_idx = content.find(start_marker)
    end_idx = content.find(end_marker)

    if start_idx == -1:
        return ""
    if end_idx == -1:
        end_idx = len(content)

    return content[start_idx:end_idx]


def count_checkboxes(content: str) -> tuple:
    """Count checkboxes in content. Returns (checked, total)."""
    checked = len(re.findall(r'- \[[xX]\]', content))
    unchecked = len(re.findall(r'- \[ \]', content))
    return checked, checked + unchecked


def extract_score(content: str, pass_num: int, checkboxes_done: int = 0, checkboxes_total: int = 0) -> int:
    """Extract score for a specific pass. Auto-calculates from completion if not explicit."""
    # First try to find explicit score in content
    patterns = [
        rf'PASS {pass_num} SCORE:\s*(\d+)/10',
        rf'Pass {pass_num}.*?(\d+)/10',
    ]

    for pattern in patterns:
        match = re.search(pattern, content, re.IGNORECASE)
        if match:
            return int(match.group(1))

    # AUTO-CALCULATE score based on checkbox completion (0-10 scale)
    if checkboxes_total > 0:
        completion_pct = checkboxes_done / checkboxes_total
        # Score = completion percentage * 10, rounded
        return round(completion_pct * 10)

    return 0


def verify_pass_progress(sejr_path: Path) -> dict:
    """Verify progress across all 3 passes."""
    sejr_file = sejr_path / "SEJR_LISTE.md"

    if not sejr_file.exists():
        return {"error": "SEJR_LISTE.md not found"}

    content = sejr_file.read_text(encoding="utf-8")

    # Detect current pass
    current_pass = detect_current_pass(content)

    # Count checkboxes for each pass
    results = {
        "current_pass": current_pass,
        "pass_1": {},
        "pass_2": {},
        "pass_3": {},
        "can_archive": False,
    }

    # Pass 1 analysis (matches actual SEJR_LISTE.md format with emojis)
    pass1_content = extract_section(content, "# ü•â PASS 1:", "# üîç PASS 1 ‚Üí")
    p1_done, p1_total = count_checkboxes(pass1_content)
    p1_score = extract_score(content, 1, p1_done, p1_total)  # Auto-calculate if not explicit
    results["pass_1"] = {
        "checkboxes_done": p1_done,
        "checkboxes_total": p1_total,
        "completion_pct": (p1_done / p1_total * 100) if p1_total > 0 else 0,
        "score": p1_score,
        "complete": p1_done == p1_total and p1_total > 0,
    }

    # Pass 2 analysis
    pass2_content = extract_section(content, "# ü•à PASS 2:", "# üîç PASS 2 ‚Üí")
    p2_done, p2_total = count_checkboxes(pass2_content)
    p2_score = extract_score(content, 2, p2_done, p2_total)  # Auto-calculate if not explicit
    results["pass_2"] = {
        "checkboxes_done": p2_done,
        "checkboxes_total": p2_total,
        "completion_pct": (p2_done / p2_total * 100) if p2_total > 0 else 0,
        "score": p2_score,
        "complete": p2_done == p2_total and p2_total > 0,
        "improved_from_pass1": p2_score > p1_score if p2_score > 0 and p1_score > 0 else None,
    }

    # Pass 3 analysis
    pass3_content = extract_section(content, "# ü•á PASS 3:", "# üì¶ SEMANTISK KONKLUSION")
    p3_done, p3_total = count_checkboxes(pass3_content)
    p3_score = extract_score(content, 3, p3_done, p3_total)  # Auto-calculate if not explicit
    results["pass_3"] = {
        "checkboxes_done": p3_done,
        "checkboxes_total": p3_total,
        "completion_pct": (p3_done / p3_total * 100) if p3_total > 0 else 0,
        "score": p3_score,
        "complete": p3_done == p3_total and p3_total > 0,
        "improved_from_pass2": p3_score > p2_score if p3_score > 0 and p2_score > 0 else None,
    }

    # Final verification check
    final_section = extract_section(content, "# ‚úÖ FINAL VERIFICATION", "# üèÜ SEMANTISK KONKLUSION")
    final_done, final_total = count_checkboxes(final_section)
    results["final_verification"] = {
        "done": final_done,
        "total": final_total,
        "complete": final_done == final_total and final_total >= 5,  # Minimum 5 tests
    }

    # Calculate total
    total_score = p1_score + p2_score + p3_score
    results["total_score"] = total_score

    # Check if can archive
    # Improvement logic: scores must improve OR be at maximum (10) OR start from 0
    p2_improved = (p2_score > p1_score) or (p1_score == 0) or (p2_score == 10)
    p3_improved = (p3_score > p2_score) or (p2_score == 0) or (p3_score == 10)

    can_archive = (
        results["pass_1"]["complete"] and
        results["pass_2"]["complete"] and
        results["pass_3"]["complete"] and
        results["final_verification"]["complete"] and
        total_score >= 24 and  # Minimum 24/30
        p2_improved and
        p3_improved
    )
    results["can_archive"] = can_archive

    return results


def print_pass_status(results: dict):
    """Print formatted pass status."""
    print("\n" + "=" * 60)
    print("üìä 3-PASS KONKURRENCE STATUS")
    print("=" * 60)

    current = results["current_pass"]

    # Pass 1
    p1 = results["pass_1"]
    status = "‚úÖ" if p1["complete"] else "üîµ" if current == 1 else "‚è≥"
    print(f"\n{status} PASS 1: PLANL√ÜGNING")
    print(f"   Checkboxes: {p1['checkboxes_done']}/{p1['checkboxes_total']} ({p1['completion_pct']:.0f}%)")
    print(f"   Score: {p1['score']}/10")

    # Pass 2
    p2 = results["pass_2"]
    status = "‚úÖ" if p2["complete"] else "üîµ" if current == 2 else "‚è≥"
    print(f"\n{status} PASS 2: EKSEKVERING")
    print(f"   Checkboxes: {p2['checkboxes_done']}/{p2['checkboxes_total']} ({p2['completion_pct']:.0f}%)")
    print(f"   Score: {p2['score']}/10")
    if p2["improved_from_pass1"] is not None:
        imp_status = "‚úÖ" if p2["improved_from_pass1"] else "‚ùå SKAL FORBEDRES!"
        print(f"   Forbedring fra Pass 1: {imp_status}")

    # Pass 3
    p3 = results["pass_3"]
    status = "‚úÖ" if p3["complete"] else "üîµ" if current == 3 else "‚è≥"
    print(f"\n{status} PASS 3: 7-DNA REVIEW")
    print(f"   Checkboxes: {p3['checkboxes_done']}/{p3['checkboxes_total']} ({p3['completion_pct']:.0f}%)")
    print(f"   Score: {p3['score']}/10")
    if p3["improved_from_pass2"] is not None:
        imp_status = "‚úÖ" if p3["improved_from_pass2"] else "‚ùå SKAL FORBEDRES!"
        print(f"   Forbedring fra Pass 2: {imp_status}")

    # Final verification
    fv = results["final_verification"]
    status = "‚úÖ" if fv["complete"] else "‚è≥"
    print(f"\n{status} FINAL VERIFICATION")
    print(f"   Tests: {fv['done']}/{fv['total']} (minimum 5 kr√¶vet)")

    # Total
    print("\n" + "-" * 60)
    print(f"üìà TOTAL SCORE: {results['total_score']}/30 (minimum 24 kr√¶vet)")

    # Archive status
    print("\n" + "-" * 60)
    if results["can_archive"]:
        print("‚úÖ KAN ARKIVERES - Alle 3 passes gennemf√∏rt!")
    else:
        print("üîí ARKIVERING BLOKERET - Mangler:")
        if not results["pass_1"]["complete"]:
            print("   ‚Ä¢ Pass 1 ikke f√¶rdig")
        if not results["pass_2"]["complete"]:
            print("   ‚Ä¢ Pass 2 ikke f√¶rdig")
        elif results["pass_2"]["improved_from_pass1"] == False:
            print("   ‚Ä¢ Pass 2 score SKAL v√¶re h√∏jere end Pass 1")
        if not results["pass_3"]["complete"]:
            print("   ‚Ä¢ Pass 3 ikke f√¶rdig")
        elif results["pass_3"]["improved_from_pass2"] == False:
            print("   ‚Ä¢ Pass 3 score SKAL v√¶re h√∏jere end Pass 2")
        if not results["final_verification"]["complete"]:
            print(f"   ‚Ä¢ Final verification mangler ({fv['done']}/{fv['total']} tests, min 5)")
        if results["total_score"] < 24:
            print(f"   ‚Ä¢ Total score for lav ({results['total_score']}/30, min 24)")

    print("=" * 60 + "\n")


def run_verification(sejr_path: Path):
    """Run full 3-pass verification for a sejr liste."""
    sejr_file = sejr_path / "SEJR_LISTE.md"
    status_file = sejr_path / "STATUS.yaml"

    if not sejr_file.exists():
        print(f"‚ùå SEJR_LISTE.md not found in {sejr_path}")
        return False

    print(f"üîç Verifying: {sejr_path.name}\n")

    # Get 3-pass progress
    results = verify_pass_progress(sejr_path)

    if "error" in results:
        print(f"‚ùå {results['error']}")
        return False

    # Print status
    print_pass_status(results)

    # Update STATUS.yaml
    status = parse_yaml_simple(status_file) if status_file.exists() else {}

    status['sejr_name'] = sejr_path.name
    status['last_verification'] = datetime.now().isoformat()
    status['current_pass'] = results['current_pass']

    status['pass_1_complete'] = results['pass_1']['complete']
    status['pass_1_score'] = results['pass_1']['score']
    status['pass_1_pct'] = int(results['pass_1']['completion_pct'])

    status['pass_2_complete'] = results['pass_2']['complete']
    status['pass_2_score'] = results['pass_2']['score']
    status['pass_2_pct'] = int(results['pass_2']['completion_pct'])

    status['pass_3_complete'] = results['pass_3']['complete']
    status['pass_3_score'] = results['pass_3']['score']
    status['pass_3_pct'] = int(results['pass_3']['completion_pct'])

    status['final_verification_complete'] = results['final_verification']['complete']
    status['total_score'] = results['total_score']
    status['can_archive'] = results['can_archive']

    # Overall completion percentage (weighted across all passes)
    total_done = (
        results['pass_1']['checkboxes_done'] +
        results['pass_2']['checkboxes_done'] +
        results['pass_3']['checkboxes_done'] +
        results['final_verification']['done']
    )
    total_items = (
        results['pass_1']['checkboxes_total'] +
        results['pass_2']['checkboxes_total'] +
        results['pass_3']['checkboxes_total'] +
        results['final_verification']['total']
    )
    status['completion_percentage'] = int((total_done / total_items * 100)) if total_items > 0 else 0

    # Status label
    if results['can_archive']:
        status['status'] = 'ready_to_archive'
    elif results['current_pass'] == 1:
        status['status'] = 'pass_1_in_progress'
    elif results['current_pass'] == 2:
        status['status'] = 'pass_2_in_progress'
    else:
        status['status'] = 'pass_3_in_progress'

    write_yaml_simple(status_file, status)
    print(f"üìä Status updated: {status_file}")

    return results['can_archive']


def verify_all(system_path: Path):
    """Verify all active sejr lister."""
    active_dir = system_path / "10_ACTIVE"

    if not active_dir.exists():
        print("‚ùå No 10_ACTIVE directory found")
        return

    sejr_folders = [f for f in active_dir.iterdir() if f.is_dir()]

    if not sejr_folders:
        print("‚ÑπÔ∏è  No active sejr lister found in 10_ACTIVE/")
        return

    print(f"Found {len(sejr_folders)} active sejr lister\n")
    print("=" * 60)

    ready_to_archive = []
    for sejr_path in sejr_folders:
        if run_verification(sejr_path):
            ready_to_archive.append(sejr_path.name)
        print("=" * 60)

    if ready_to_archive:
        print(f"\n‚úÖ READY TO ARCHIVE ({len(ready_to_archive)}):")
        for name in ready_to_archive:
            print(f"   ‚Ä¢ {name}")
        print(f"\nArchive with: python scripts/auto_archive.py --sejr <name>")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Auto-verify sejr liste with 3-PASS system")
    parser.add_argument("--sejr", help="Specific sejr folder name to verify")
    parser.add_argument("--all", action="store_true", help="Verify all active sejr lister")
    args = parser.parse_args()

    system_path = Path(__file__).parent.parent

    if args.all:
        verify_all(system_path)
    elif args.sejr:
        sejr_path = system_path / "10_ACTIVE" / args.sejr
        if sejr_path.exists():
            run_verification(sejr_path)
        else:
            print(f"‚ùå Sejr folder not found: {sejr_path}")
    else:
        verify_all(system_path)
