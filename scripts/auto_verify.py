#!/usr/bin/env python3
"""
Auto-verify sejr liste completion with 3-PASS SYSTEM
Part of SEJR LISTE SYSTEM - DNA Layer 3 (SELF-VERIFYING)

INGEN EXTERNAL DEPENDENCIES - Kun Python standard library

3-PASS KONKURRENCE:
- Pass 1: Get it working (basic functionality)
- Pass 2: Make it better (improvements required)
- Pass 3: Make it best (optimization + final verification)

REGEL: Kan IKKE arkiveres f√∏r alle 3 passes er gennemf√∏rt og verificeret.
"""

import argparse
import subprocess
import re
import sys
import yaml
from pathlib import Path
from datetime import datetime, timezone

sys.path.insert(0, str(Path(__file__).parent))
from yaml_utils import parse_yaml_simple


def write_yaml_simple(filepath: Path, data: dict):
    """Write YAML using PyYAML (preserves nested structures)."""
    header = f"# STATUS.yaml - Auto-generated by auto_verify.py\n# Last updated: {datetime.now(timezone.utc).astimezone().isoformat()}\n\n"
    yaml_content = yaml.dump(data, default_flow_style=False, allow_unicode=True, sort_keys=False, width=120)
    filepath.write_text(header + yaml_content, encoding="utf-8")


# ============================================================================
# 3-PASS VERIFICATION SYSTEM
# ============================================================================

def detect_current_pass(content: str) -> int:
    """Detect which pass is currently active based on checkbox completion.

    Supports BOTH formats:
    - Emoji: #  PASS 1: (from generate_sejr.py)
    - Plain: ## PASS 1: FUNGERENDE (manually created)
    """
    # Check Pass 1 completion (try emoji format first, then plain)
    pass1_section = extract_section_flexible(content, pass_num=1)
    pass1_done, pass1_total = count_checkboxes(pass1_section)

    # Check Pass 1 Review
    pass1_review = extract_section_flexible(content, pass_num=1, review=True)
    pass1_review_done, pass1_review_total = count_checkboxes(pass1_review)

    # Check Pass 2 completion
    pass2_section = extract_section_flexible(content, pass_num=2)
    pass2_done, pass2_total = count_checkboxes(pass2_section)

    # Check Pass 2 Review
    pass2_review = extract_section_flexible(content, pass_num=2, review=True)
    pass2_review_done, pass2_review_total = count_checkboxes(pass2_review)

    # Check Pass 3 completion
    pass3_section = extract_section_flexible(content, pass_num=3)
    pass3_done, pass3_total = count_checkboxes(pass3_section)

    # Determine current pass
    if pass1_total > 0 and pass1_done < pass1_total:
        return 1
    elif pass1_review_total > 0 and pass1_review_done < pass1_review_total:
        return 1  # Still in review phase of pass 1
    elif pass2_total > 0 and pass2_done < pass2_total:
        return 2
    elif pass2_review_total > 0 and pass2_review_done < pass2_review_total:
        return 2  # Still in review phase of pass 2
    elif pass3_total > 0 and pass3_done < pass3_total:
        return 3
    elif pass3_done == pass3_total and pass3_total > 0:
        return 3  # Pass 3 complete

    return 1  # Default to pass 1


def extract_section(content: str, start_marker: str, end_marker: str) -> str:
    """Extract a section of content between markers."""
    start_idx = content.find(start_marker)
    end_idx = content.find(end_marker)

    if start_idx == -1:
        return ""
    if end_idx == -1:
        end_idx = len(content)

    return content[start_idx:end_idx]


def extract_section_flexible(content: str, pass_num: int, review: bool = False) -> str:
    """Extract pass section supporting BOTH emoji and plain formats.

    Emoji format (generate_sejr.py): # ü•â PASS 1:
    Plain format (manual): ## PASS 1: FUNGERENDE
    Review format: ## PASS 1 REVIEW / # üîç PASS 1 ‚Üí
    """
    PASS_EMOJI = {1: "ü•â", 2: "ü•à", 3: "ü•á"}
    NEXT_PASS = {1: 2, 2: 3, 3: None}

    if review:
        # Try emoji review markers first
        start_markers = [
            f"# üîç PASS {pass_num} ‚Üí",
            f"## PASS {pass_num} REVIEW",
        ]
        next_num = NEXT_PASS.get(pass_num)
        if next_num:
            end_markers = [
                f"# {PASS_EMOJI.get(next_num, '')} PASS {next_num}:",
                f"## PASS {next_num}:",
            ]
        else:
            end_markers = [
                "# üì¶ SEMANTISK KONKLUSION",
                "## SEMANTISK KONKLUSION",
                "## VERIFIKATION",
            ]
    else:
        # Try emoji section markers first, then plain
        emoji = PASS_EMOJI.get(pass_num, "")
        start_markers = [
            f"# {emoji} PASS {pass_num}:",
            f"## PASS {pass_num}:",
        ]
        # End at review section or next pass
        end_markers = [
            f"# üîç PASS {pass_num} ‚Üí",
            f"## PASS {pass_num} REVIEW",
        ]

    # Try each start marker
    for start_m in start_markers:
        start_idx = content.find(start_m)
        if start_idx != -1:
            # Find nearest end marker
            best_end = len(content)
            for end_m in end_markers:
                end_idx = content.find(end_m, start_idx + len(start_m))
                if end_idx != -1 and end_idx < best_end:
                    best_end = end_idx
            return content[start_idx:best_end]

    return ""


def count_checkboxes(content: str) -> tuple:
    """Count checkboxes in content. Returns (checked, total)."""
    checked = len(re.findall(r'- \[[xX]\]', content))
    unchecked = len(re.findall(r'- \[ \]', content))
    return checked, checked + unchecked


def extract_score(content: str, pass_num: int, checkboxes_done: int = 0, checkboxes_total: int = 0) -> int:
    """Extract score for a specific pass. Auto-calculates from completion if not explicit."""
    # First try to find explicit score in content
    patterns = [
        rf'PASS {pass_num} SCORE:\s*(\d+)/10',
        rf'Pass {pass_num}.*?(\d+)/10',
    ]

    for pattern in patterns:
        match = re.search(pattern, content, re.IGNORECASE)
        if match:
            return int(match.group(1))

    # AUTO-CALCULATE score based on checkbox completion (0-10 scale)
    if checkboxes_total > 0:
        completion_pct = checkboxes_done / checkboxes_total
        # Score = completion percentage * 10, rounded
        return round(completion_pct * 10)

    return 0


def verify_pass_progress(sejr_path: Path) -> dict:
    """Verify progress across all 3 passes."""
    sejr_file = sejr_path / "SEJR_LISTE.md"

    if not sejr_file.exists():
        return {"error": "SEJR_LISTE.md not found"}

    content = sejr_file.read_text(encoding="utf-8")

    # Detect current pass
    current_pass = detect_current_pass(content)

    # Count checkboxes for each pass
    results = {
        "current_pass": current_pass,
        "pass_1": {},
        "pass_2": {},
        "pass_3": {},
        "can_archive": False,
    }

    # Pass 1 analysis (flexible: supports BOTH emoji and plain format)
    pass1_content = extract_section_flexible(content, pass_num=1)
    p1_done, p1_total = count_checkboxes(pass1_content)
    p1_score = extract_score(content, 1, p1_done, p1_total)
    results["pass_1"] = {
        "checkboxes_done": p1_done,
        "checkboxes_total": p1_total,
        "completion_pct": (p1_done / p1_total * 100) if p1_total > 0 else 0,
        "score": p1_score,
        "complete": p1_done == p1_total and p1_total > 0,
    }

    # Pass 2 analysis (flexible format)
    pass2_content = extract_section_flexible(content, pass_num=2)
    p2_done, p2_total = count_checkboxes(pass2_content)
    p2_score = extract_score(content, 2, p2_done, p2_total)
    results["pass_2"] = {
        "checkboxes_done": p2_done,
        "checkboxes_total": p2_total,
        "completion_pct": (p2_done / p2_total * 100) if p2_total > 0 else 0,
        "score": p2_score,
        "complete": p2_done == p2_total and p2_total > 0,
        "improved_from_pass1": p2_score >= p1_score if p2_score > 0 and p1_score > 0 else None,
    }

    # Pass 3 analysis (flexible format)
    pass3_content = extract_section_flexible(content, pass_num=3)
    p3_done, p3_total = count_checkboxes(pass3_content)
    p3_score = extract_score(content, 3, p3_done, p3_total)
    results["pass_3"] = {
        "checkboxes_done": p3_done,
        "checkboxes_total": p3_total,
        "completion_pct": (p3_done / p3_total * 100) if p3_total > 0 else 0,
        "score": p3_score,
        "complete": p3_done == p3_total and p3_total > 0,
        "improved_from_pass2": p3_score >= p2_score if p3_score > 0 and p2_score > 0 else None,
    }

    # Final verification check (flexible: emoji or plain markers)
    final_section = extract_section(content, "# [OK] FINAL VERIFICATION", "# [VICTORY] SEMANTISK KONKLUSION")
    if not final_section:
        final_section = extract_section(content, "## VERIFIKATION", "## SEMANTISK KONKLUSION")
    if not final_section:
        final_section = extract_section(content, "## VERIFIKATION", "---\n\n*Oprettet")
    final_done, final_total = count_checkboxes(final_section)
    results["final_verification"] = {
        "done": final_done,
        "total": final_total,
        "complete": final_done == final_total and final_total >= 5,  # Minimum 5 tests
    }

    # Calculate total
    total_score = p1_score + p2_score + p3_score
    results["total_score"] = total_score

    # Check if can archive
    # Improvement logic: scores must improve OR be at maximum (10) OR start from 0
    # Fixed 2026-01-29: Use >= instead of > to allow equal scores when both passes
    # are fully complete. Pass 2 score 9/10 = Pass 1 score 9/10 is NOT regression.
    # Guard is against REGRESSION (lower score), not demanding strict improvement.
    p2_improved = (p2_score >= p1_score) or (p1_score == 0) or (p2_score == 10)
    p3_improved = (p3_score >= p2_score) or (p2_score == 0) or (p3_score == 10)

    can_archive = (
        results["pass_1"]["complete"] and
        results["pass_2"]["complete"] and
        results["pass_3"]["complete"] and
        results["final_verification"]["complete"] and
        total_score >= 24 and  # Minimum 24/30
        p2_improved and
        p3_improved
    )
    results["can_archive"] = can_archive

    return results


def print_pass_status(results: dict):
    """Print formatted pass status."""
    print("\n" + "=" * 60)
    print("3-PASS STATUS")
    print("=" * 60)

    current = results["current_pass"]

    # Pass 1
    p1 = results["pass_1"]
    status = "[DONE]" if p1["complete"] else "[ACTIVE]" if current == 1 else "[PENDING]"
    print(f"\n{status} PASS 1: PLANLAEGNING")
    print(f"   Checkboxes: {p1['checkboxes_done']}/{p1['checkboxes_total']} ({p1['completion_pct']:.0f}%)")
    print(f"   Score: {p1['score']}/10")

    # Pass 2
    p2 = results["pass_2"]
    status = "[DONE]" if p2["complete"] else "[ACTIVE]" if current == 2 else "[PENDING]"
    print(f"\n{status} PASS 2: EKSEKVERING")
    print(f"   Checkboxes: {p2['checkboxes_done']}/{p2['checkboxes_total']} ({p2['completion_pct']:.0f}%)")
    print(f"   Score: {p2['score']}/10")
    if p2["improved_from_pass1"] is not None:
        imp_status = "[OK]" if p2["improved_from_pass1"] else "[FAIL] SKAL FORBEDRES"
        print(f"   Forbedring fra Pass 1: {imp_status}")

    # Pass 3
    p3 = results["pass_3"]
    status = "[DONE]" if p3["complete"] else "[ACTIVE]" if current == 3 else "[PENDING]"
    print(f"\n{status} PASS 3: 7-DNA REVIEW")
    print(f"   Checkboxes: {p3['checkboxes_done']}/{p3['checkboxes_total']} ({p3['completion_pct']:.0f}%)")
    print(f"   Score: {p3['score']}/10")
    if p3["improved_from_pass2"] is not None:
        imp_status = "[OK]" if p3["improved_from_pass2"] else "[FAIL] SKAL FORBEDRES"
        print(f"   Forbedring fra Pass 2: {imp_status}")

    # Final verification
    fv = results["final_verification"]
    status = "[DONE]" if fv["complete"] else "[PENDING]"
    print(f"\n{status} FINAL VERIFICATION")
    print(f"   Tests: {fv['done']}/{fv['total']} (minimum 5 kraevet)")

    # Total
    print("\n" + "-" * 60)
    print(f"TOTAL SCORE: {results['total_score']}/30 (minimum 24 kraevet)")

    # Archive status
    print("\n" + "-" * 60)
    if results["can_archive"]:
        print("[OK] KAN ARKIVERES ‚Äî Alle 3 passes gennemfoert!")
    else:
        print("[BLOCKED] ARKIVERING BLOKERET ‚Äî Mangler:")
        if not results["pass_1"]["complete"]:
            print("   - Pass 1 ikke faerdig")
        if not results["pass_2"]["complete"]:
            print("   - Pass 2 ikke faerdig")
        elif results["pass_2"]["improved_from_pass1"] == False:
            print("   - Pass 2 score SKAL vaere hoejere end Pass 1")
        if not results["pass_3"]["complete"]:
            print("   - Pass 3 ikke faerdig")
        elif results["pass_3"]["improved_from_pass2"] == False:
            print("   - Pass 3 score SKAL vaere hoejere end Pass 2")
        if not results["final_verification"]["complete"]:
            print(f"   - Final verification mangler ({fv['done']}/{fv['total']} tests, min 5)")
        if results["total_score"] < 24:
            print(f"   - Total score for lav ({results['total_score']}/30, min 24)")

    print("=" * 60 + "\n")


def run_verification(sejr_path: Path):
    """Run full 3-pass verification for a sejr liste."""
    sejr_file = sejr_path / "SEJR_LISTE.md"
    status_file = sejr_path / "STATUS.yaml"

    if not sejr_file.exists():
        print(f"[FAIL] SEJR_LISTE.md not found in {sejr_path}")
        return False

    print(f"[SCAN] Verifying: {sejr_path.name}\n")

    # Get 3-pass progress
    results = verify_pass_progress(sejr_path)

    if "error" in results:
        print(f"[FAIL] {results['error']}")
        return False

    # Print status
    print_pass_status(results)

    # Update STATUS.yaml
    status = parse_yaml_simple(status_file) if status_file.exists() else {}

    status['sejr_name'] = sejr_path.name
    status['last_verification'] = datetime.now(timezone.utc).astimezone().isoformat()
    status['current_pass'] = results['current_pass']

    status['pass_1_complete'] = results['pass_1']['complete']
    status['pass_1_score'] = results['pass_1']['score']
    status['pass_1_pct'] = int(results['pass_1']['completion_pct'])

    status['pass_2_complete'] = results['pass_2']['complete']
    status['pass_2_score'] = results['pass_2']['score']
    status['pass_2_pct'] = int(results['pass_2']['completion_pct'])

    status['pass_3_complete'] = results['pass_3']['complete']
    status['pass_3_score'] = results['pass_3']['score']
    status['pass_3_pct'] = int(results['pass_3']['completion_pct'])

    status['final_verification_complete'] = results['final_verification']['complete']
    status['total_score'] = results['total_score']
    status['can_archive'] = results['can_archive']

    # Overall completion percentage (weighted across all passes)
    total_done = (
        results['pass_1']['checkboxes_done'] +
        results['pass_2']['checkboxes_done'] +
        results['pass_3']['checkboxes_done'] +
        results['final_verification']['done']
    )
    total_items = (
        results['pass_1']['checkboxes_total'] +
        results['pass_2']['checkboxes_total'] +
        results['pass_3']['checkboxes_total'] +
        results['final_verification']['total']
    )
    status['completion_percentage'] = int((total_done / total_items * 100)) if total_items > 0 else 0

    # Status label
    if results['can_archive']:
        status['status'] = 'ready_to_archive'
    elif results['current_pass'] == 1:
        status['status'] = 'pass_1_in_progress'
    elif results['current_pass'] == 2:
        status['status'] = 'pass_2_in_progress'
    else:
        status['status'] = 'pass_3_in_progress'

    write_yaml_simple(status_file, status)
    print(f"[OK] Status updated: {status_file}")

    return results['can_archive']


def verify_all(system_path: Path):
    """Verify all active sejr lister."""
    active_dir = system_path / "10_ACTIVE"

    if not active_dir.exists():
        print("[FAIL] No 10_ACTIVE directory found")
        return

    sejr_folders = [f for f in active_dir.iterdir() if f.is_dir()]

    if not sejr_folders:
        print("[INFO] No active sejr lister found in 10_ACTIVE/")
        return

    print(f"Found {len(sejr_folders)} active sejr lister\n")
    print("=" * 60)

    ready_to_archive = []
    for sejr_path in sejr_folders:
        if run_verification(sejr_path):
            ready_to_archive.append(sejr_path.name)
        print("=" * 60)

    if ready_to_archive:
        print(f"\n[OK] READY TO ARCHIVE ({len(ready_to_archive)}):")
        for name in ready_to_archive:
            print(f"   ‚Ä¢ {name}")
        print(f"\nArchive with: python scripts/auto_archive.py --sejr <name>")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Auto-verify sejr liste with 3-PASS system")
    parser.add_argument("--sejr", help="Specific sejr folder name to verify")
    parser.add_argument("--all", action="store_true", help="Verify all active sejr lister")
    args = parser.parse_args()

    system_path = Path(__file__).parent.parent

    if args.all:
        verify_all(system_path)
    elif args.sejr:
        sejr_path = system_path / "10_ACTIVE" / args.sejr
        if sejr_path.exists():
            run_verification(sejr_path)
        else:
            print(f"[FAIL] Sejr folder not found: {sejr_path}")
    else:
        verify_all(system_path)
